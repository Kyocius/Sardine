# C++ 到 Java 转换说明

## 主要变化

### 1. 内存管理
- **C++**: 使用原始指针和RAII (Resource Acquisition Is Initialization)
- **Java**: 使用对象引用和垃圾回收，通过 AutoCloseable 接口实现类似RAII的功能

### 2. 寄存器分配器 (NaiveAllocator)
- **C++**: 使用移动语义和析构函数自动释放寄存器
- **Java**: 使用 try-with-resources 语句和 AutoCloseable 接口

### 3. 集合类型
- **C++**: `std::unordered_map`, `std::set`, `std::vector`
- **Java**: `HashMap`, `TreeSet`, `ArrayList`

### 4. 函数指针/Lambda
- **C++**: 使用 `std::function` 和 lambda 表达式
- **Java**: 使用方法引用和私有方法

### 5. 输出流
- **C++**: `std::ostream` 
- **Java**: `PrintStream`

### 6. 错误处理
- **C++**: `olc_unreachable()` 宏
- **Java**: 抛出 `RuntimeException`

### 7. 类型转换
- **C++**: `dyn_cast`, `cast`, `isa`
- **Java**: `instanceof` 和显式类型转换

### 8. 模板/泛型
- **C++**: 模板函数 `template <typename T>`
- **Java**: 有界泛型 `<T extends Value>`

## 关键设计决策

### Reg 类的实现
C++版本使用RAII和移动语义：
```cpp
struct Reg {
    ~Reg(); // 析构函数自动释放寄存器
    Reg(Reg &&); // 移动构造函数
    Reg &operator=(Reg &&); // 移动赋值
};
```

Java版本使用AutoCloseable：
```java
public class Reg implements AutoCloseable {
    @Override
    public void close() { /* 释放寄存器 */ }
}
```

使用方式：
```java
try (Reg reg = regAlloc.allocReg(val)) {
    // 使用寄存器
} // 自动调用close()释放寄存器
```

### 静态映射表
C++版本在文件末尾定义：
```cpp
static std::unordered_map<std::string, std::string> intInstr2FltInstrOpCode{...};
```

Java版本使用静态初始化块：
```java
private static final Map<String, String> intInstr2FltInstrOpCode = new HashMap<>();
static {
    intInstr2FltInstrOpCode.put("add", "vadd.f32");
    // ...
}
```

## 依赖的Java类
转换后的代码需要以下IR包中的类：
- `Value`, `Type`, `Tag`
- `Instruction`, `BinaryInst`, `LoadInst`, `StoreInst`, 等
- `BasicBlock`, `Function`, `Module`
- `GlobalVariable`, `ConstantValue`, `ConstantArray`
- `AllocaInst`, `CallInst`, `BranchInst`, `ReturnInst`, 等

## 使用示例
```java
PrintStream output = System.out;
ArmWriter writer = new ArmWriter(output);
writer.printModule(module);
```

## 注意事项
1. Java版本假设所有IR类都有相应的getter方法
2. 错误处理统一使用RuntimeException
3. 资源管理依赖try-with-resources语句
4. 某些C++特有的优化（如移动语义）在Java中由垃圾回收器处理
