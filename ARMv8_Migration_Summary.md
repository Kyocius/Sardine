# ARM v7 到 ARMv8-A 64位架构升级总结

## 已完成的修改

### 1. 寄存器命名更新 (ArmCPUReg.java)
- **通用寄存器**: 从 r0-r15 更新为 x0-x30
- **栈指针**: 保持 sp，但现在是 x31
- **链接寄存器**: 从 r14 更新为 x30 
- **参数寄存器**: 从 4个 (r0-r3) 增加到 8个 (x0-x7)
- **保留寄存器**: 更新为 x19-x28, x29(FP), x30(LR), x31(SP)

### 2. 浮点寄存器更新 (ArmFPUReg.java)
- **寄存器命名**: 从 s0-s31 (32位单精度) 更新为 d0-d31 (64位双精度)
- **参数寄存器**: 从 4个 增加到 8个 (d0-d7)
- **保留寄存器**: 更新为 d8-d15

### 3. 指令集更新
#### 浮点指令 (ArmBinary.java)
- `vadd.f32` → `fadd`
- `vsub.f32` → `fsub` 
- `vmul.f32` → `fmul`
- `vdiv.f32` → `fdiv`

#### 系统调用指令 (ArmSyscall.java)
- `swi` → `svc` (ARMv8-A 使用 svc 指令)

#### 浮点比较 (ArmVCompare.java)
- `vcmp.f32` + `vmrs` → `fcmp`

#### 浮点转换 (ArmCvt.java)
- `vcvt.f32.s32` → `scvtf` (整数到浮点)
- `vcvt.s32.f32` → `fcvtzs` (浮点到整数)

#### 浮点移动 (ArmFMv.java, ArmConvMv.java)
- `vmov` → `fmov`

#### 浮点加载/存储 (ArmVLoad.java, ArmFSw.java)
- `vldr` → `ldr`
- `vstr` → `str`

#### 返回指令 (ArmRet.java)
- `bx lr` → `ret`

#### 有符号乘法长 (ArmSmull.java)
- 简化为单个64位结果寄存器

### 4. 系统调用号更新 (ArmCodeGen.java)
- **clone**: 120 → 220，使用 x8 寄存器存放系统调用号
- **exit**: 1 → 93，使用 x8 寄存器存放系统调用号

### 5. 内存和数据大小
- **寄存器存储变量**: 从 4字节 更新为 8字节 (指针大小变化)
- **数组元素大小**: 保持 4字节 (整数仍然是32位)

### 6. 64位除法库函数
- `__aeabi_ldivmod` → `__divti3` (AArch64 128位除法函数)

## 主要架构差异

### ARMv7 vs ARMv8-A
1. **寄存器宽度**: 32位 → 64位
2. **寄存器数量**: 16个 → 31个通用寄存器
3. **浮点**: 单精度s寄存器 → 双精度d寄存器
4. **系统调用**: 系统调用号在 r7 → x8
5. **指令集**: 从32位ARM指令集 → 64位AArch64指令集

## 需要进一步验证的部分
1. **立即数加载**: movw/movt 组合可能需要更新为 mov/movk
2. **内存寻址**: 需要验证地址计算的正确性
3. **调用约定**: 确保参数传递符合AAPCS64标准
4. **栈对齐**: ARMv8-A 要求16字节栈对齐

## 下一步建议
1. 测试编译生成的代码
2. 验证系统调用的正确性
3. 检查浮点运算的精度
4. 确认内存布局的兼容性
